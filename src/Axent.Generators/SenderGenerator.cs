using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Axent.SourceGenerator;

[Generator]
public sealed class SenderGenerator : IIncrementalGenerator
{
    private const string AxentModuleInitializerFile = "AxentModuleInitializer.g.cs";
    private const string SenderFile = "Sender.g.cs";
    private const string PipelinesFile = "Pipelines.g.cs";

    private const string RequestMetadataName = "Axent.Abstractions.IRequest`1";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var requestTypes =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsCandidate(node),
                    transform: static (ctx, ct) => GetRequestInfo(ctx, ct))
                .Where(static info => info is not null)
                .WithComparer(RequestTypeInfo.Comparer)
                .Collect();

        context.RegisterSourceOutput(
            requestTypes,
            static (spc, types) => Execute(spc, types));
    }

    private static bool IsCandidate(SyntaxNode node)
        => node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 };

    private static RequestTypeInfo? GetRequestInfo(
        GeneratorSyntaxContext ctx,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if (ctx.SemanticModel.GetDeclaredSymbol(ctx.Node, ct) is not INamedTypeSymbol symbol
            || symbol.IsAbstract
            || symbol.IsStatic)
        {
            return null;
        }

        var requestInterface =
            ctx.SemanticModel.Compilation.GetTypeByMetadataName(RequestMetadataName);

        if (requestInterface is null)
        {
            return null;
        }

        foreach (var iface in symbol.AllInterfaces)
        {
            if (!SymbolEqualityComparer.Default.Equals(
                    iface.OriginalDefinition,
                    requestInterface))
            {
                continue;
            }

            var responseType = iface.TypeArguments[0];

            return new RequestTypeInfo(
                RequestFullName:
                    symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                ResponseFullName:
                    responseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                // Simple name used for the generated pipeline class, e.g.
                // "global::MyApp.CreateUserRequest" -> "CreateUserRequestPipeline"
                PipelineClassName:
                    $"{symbol.Name}Pipeline");
        }

        return null;
    }

    private static void Execute(
        SourceProductionContext ctx,
        ImmutableArray<RequestTypeInfo?> types)
    {
        var requests =
            types
                .Where(static t => t is not null)
                .Select(static t => t!)
                .OrderBy(static t => t.RequestFullName)
                .ToImmutableArray();

        if (requests.Length == 0)
        {
            return;
        }

        ctx.AddSource(SenderFile,
            SourceText.From(BuildSenderSource(requests), Encoding.UTF8));

        ctx.AddSource(PipelinesFile,
            SourceText.From(BuildPipelinesSource(requests), Encoding.UTF8));

        ctx.AddSource(
            AxentModuleInitializerFile,
            SourceText.From(BuildModuleInitializerSource(requests), Encoding.UTF8));
    }

    private static string BuildSenderSource(ImmutableArray<RequestTypeInfo> types)
    {
        var sb = new StringBuilder();

        sb.AppendLine("""
            // <auto-generated />
            #nullable enable

            using System;
            using System.Threading;
            using System.Threading.Tasks;
            using Axent.Abstractions;
            using Microsoft.Extensions.DependencyInjection;

            namespace Axent.Generated;

            internal sealed class Sender : ISender
            {
                private readonly IServiceProvider _serviceProvider;

                public Sender(IServiceProvider serviceProvider)
                {
                    _serviceProvider = serviceProvider;
                }

                public Task<Response<TResponse>> SendAsync<TResponse>(
                    IRequest<TResponse> request,
                    CancellationToken cancellationToken)
                {
                    return request switch
                    {
            """);

        foreach (var type in types)
        {
            sb.AppendLine(
                $"            {type.RequestFullName} r => " +
                $"(Task<Response<TResponse>>)(object)" +
                $"_serviceProvider.GetRequiredService<{type.PipelineClassName}>().ExecuteAsync(r, cancellationToken),");
        }

        sb.AppendLine("""
                    _ => throw new InvalidOperationException(
                             $"No pipeline found for request type '{request.GetType().FullName}'.")
                };
            }
            }
            """);

        return sb.ToString();
    }

    private static string BuildPipelinesSource(ImmutableArray<RequestTypeInfo> types)
    {
        var sb = new StringBuilder();

        sb.AppendLine("""
            // <auto-generated />
            #nullable enable

            using System.Collections.Generic;
            using System.Threading;
            using System.Threading.Tasks;
            using Axent.Abstractions;

            namespace Axent.Generated;

            """);

        foreach (var type in types)
        {
            sb.AppendLine($$"""
                internal sealed class {{type.PipelineClassName}}
                {
                    private readonly IPipelineExecutorService _executor;
                    private readonly IRequestContextFactory _contextFactory;
                    private readonly IAxentPipe<{{type.RequestFullName}}, {{type.ResponseFullName}}>[] _pipeline;

                    public {{type.PipelineClassName}}(
                        IPipelineExecutorService executor,
                        IRequestContextFactory contextFactory,
                        IEnumerable<IAxentPipe<{{type.RequestFullName}}, {{type.ResponseFullName}}>> pipes,
                        IHandlerPipe<{{type.RequestFullName}}, {{type.ResponseFullName}}> handlerPipe)
                    {
                        _executor = executor;
                        _contextFactory = contextFactory;
                        _pipeline = [..pipes, handlerPipe];
                    }

                    public async Task<Response<{{type.ResponseFullName}}>> ExecuteAsync(
                        {{type.RequestFullName}} request,
                        CancellationToken cancellationToken)
                    {
                        var context = _contextFactory.Get(request);
                        return await _executor.ExecuteAsync(_pipeline, context, cancellationToken);
                    }
                }

                """);
        }

        return sb.ToString();
    }

    private static string BuildModuleInitializerSource(ImmutableArray<RequestTypeInfo> types)
    {
        var sb = new StringBuilder();

        sb.AppendLine("""
                      // <auto-generated />
                      #nullable enable

                      using System.Runtime.CompilerServices;
                      using Axent.Abstractions;
                      using Axent.Core;
                      using Microsoft.Extensions.DependencyInjection;

                      namespace Axent.Generated;

                      internal static class SenderModuleInitializer
                      {
                          [ModuleInitializer]
                          internal static void Register()
                          {
                              AxentSenderRegistry.Register(static services =>
                              {
                                  services.AddScoped<ISender, Sender>();
                      """);

        foreach (var type in types)
        {
            sb.AppendLine($"            services.AddScoped<{type.PipelineClassName}>();");
        }

        sb.AppendLine("""
                              });
                          }
                      }
                      """);

        return sb.ToString();
    }
}

internal sealed record RequestTypeInfo(
    string RequestFullName,
    string ResponseFullName,
    string PipelineClassName)
{
    public static readonly IEqualityComparer<RequestTypeInfo?> Comparer =
        EqualityComparer<RequestTypeInfo?>.Default;
}
